<?xml version="1.0" encoding="utf-8"?>

<!--

BigBlueButton open source conferencing system - http://www.bigbluebutton.org/

Copyright (c) 2015 BigBlueButton Inc. and by respective authors (see below).

This program is free software; you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free Software
Foundation; either version 3.0 of the License, or (at your option) any later
version.

BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.

-->

<mx:Canvas xmlns="org.bigbluebutton.common.*"
		xmlns:mx="http://www.adobe.com/2006/mxml"
		width="100%"
		height="100%"
		creationComplete="onCreationComplete()"
		implements="org.bigbluebutton.common.IBbbCanvas"
		xmlns:mate="http://mate.asfusion.com/"
		backgroundColor="#C0C0C0">

	<mate:Listener type="{ViewStreamEvent.STOP}" method="onStopViewStreamEvent"/>
	<mate:Listener type="{LocaleChangeEvent.LOCALE_CHANGED}" method="localeChanged"/>

	<mx:Script>
		<![CDATA[
			import mx.core.UIComponent;
			import mx.events.ResizeEvent;

			import org.as3commons.logging.api.ILogger;
			import org.as3commons.logging.api.getClassLogger;

			import org.bigbluebutton.common.events.LocaleChangeEvent;
			import org.bigbluebutton.modules.screenshare.events.ViewStreamEvent;
			import org.bigbluebutton.modules.screenshare.managers.SmartWindowResizer;
			import org.bigbluebutton.modules.screenshare.services.red5.WebRTCConnectionEvent;
			import org.bigbluebutton.util.i18n.ResourceUtil;

			private static const LOGGER:ILogger = getClassLogger(WebRTCDesktopViewWindow);

			private var video:Video;
			private var ns:NetStream;
			private var videoWithWarnings:VideoWithWarnings = new VideoWithWarnings();
			private var videoHolder:UIComponent = new UIComponent();
			private var videoHeight:Number = 1;
			private var videoWidth:Number = 1;
			private var streamId:String;
			private var nc:NetConnection;
			private var loaded:Boolean = false;
			private var resizer:SmartWindowResizer = new SmartWindowResizer();

			private var whiteboardCanvas:IBbbCanvas = null;
			private var whiteboardCanvasHolder:Canvas = new Canvas();

			private static const VIDEO_WIDTH_PADDING:int = 7;
			private static const VIDEO_HEIGHT_PADDING:int = 65;

			[Bindable] private var _actualSize:Boolean = false;

			private function onCreationComplete():void{
				addEventListener(ResizeEvent.RESIZE, onResizeEvent);

				this.addChildAt(videoWithWarnings, 0);
				videoHolder = videoWithWarnings.videoHolder;
				videoHolder.percentWidth = 100;
				videoHolder.percentHeight = 100;

				loaded = true;
				onResizeEvent();
				resourcesChanged();
			}

			private function onResizeEvent(e:ResizeEvent = null):void {
				if (!loaded) return;
				LOGGER.debug("onResizeEvent");
				if (actualSize) {
					onResizeCallback(this.width, this.height, videoWidth, videoHeight, Math.max((this.width - videoWidth) / 2, 0), Math.max((this.height - videoHeight) / 2, 0));
				} else {
					resizer.onResize(this.width, this.height, false, video.width, video.height, videoWidth / videoHeight, false, onResizeCallback);
				}
			}

			private function onResizeCallback(externalWidth:int, externalHeight:int, internalWidth:int, internalHeight:int, internalOffsetX:int, internalOffsetY:int):void {
				if (videoHolder != null) {
					/* Reposition video within window */
					videoWithWarnings.x = internalOffsetX;
					videoWithWarnings.y = internalOffsetY;

					videoWithWarnings.width = video.width = internalWidth;
					videoWithWarnings.height = video.height = internalHeight;

					// update the whiteboard canvas holder and overlay with new video dimensions
					updateWhiteboardCanvasHolder();
					updateWhiteboardCanvasOverlay();
				}
			}

			public function startVideo(rtmp:String, width:Number, height:Number):void{
				var videoURL:String;

				// split rtmp extract the streamId
				this.videoWidth = width;
				this.videoHeight = height;

				var myArray :Array = rtmp.split('/');

				streamId = myArray[5]; // Grab the streamId from the end of the rtmp string
				videoURL = rtmp.substring(0, rtmp.lastIndexOf('/'));

				connect(videoURL);
			}

			public function connect(rtmpUrl: String):void {
				nc = new NetConnection();
				nc.proxyType = "best";
				nc.objectEncoding = ObjectEncoding.AMF0;
				nc.client = this;

				nc.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
				nc.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				nc.connect(rtmpUrl);
			}

			private function setVideo():void {
				LOGGER.debug("Callback called. Adding video, its whiteboard canvas and resizing components...");
				videoHolder.addChild(video);
				addWhiteboardCanvasHolder();
				addWhiteboardCanvasOverlay();
				onResizeEvent();
			}

			private function addWhiteboardCanvasHolder():void {
				if (video != null) {
					this.addChildAt(whiteboardCanvasHolder, 1);
					LOGGER.debug("Whiteboard canvas holder added");
				}
			}

			private function cleanCanvasHolder():void {
				while (this.whiteboardCanvasHolder.rawChildren.numChildren > 0) {
					this.whiteboardCanvasHolder.rawChildren.removeChildAt(0);
				}
			}

			private function updateWhiteboardCanvasHolder():void{
				if (video != null && videoHolder != null) {
					whiteboardCanvasHolder.x = videoWithWarnings.x;
					whiteboardCanvasHolder.y = videoWithWarnings.y;
					whiteboardCanvasHolder.width = videoWithWarnings.width;
					whiteboardCanvasHolder.height = videoWithWarnings.height;
					LOGGER.debug("Whiteboard canvas holder dimensions updated");
				}
			}

			public function addWhiteboardCanvasOverlay():void {
				updateWhiteboardCanvasOverlay();
				if (video != null && whiteboardCanvas != null && videoHolder != null) {
					this.addChild(whiteboardCanvas as Canvas);
					LOGGER.debug("Whiteboard Canvas OVERLAY added");
				}
				else {
					LOGGER.error("COULD NOT add whiteboard overlay");
				}
			}

			private function updateWhiteboardCanvasOverlay():void{
				if (video != null && whiteboardCanvas != null && videoHolder != null) {
					whiteboardCanvas.moveCanvas(videoWithWarnings.x, videoWithWarnings.y);

					var zoomPercentage:Number = (videoWithWarnings.width / videoWidth)*100;
					if(zoomPercentage > 0)
						whiteboardCanvas.zoomCanvas(videoWithWarnings.width, videoWithWarnings.height, zoomPercentage);

					LOGGER.debug("Whiteboard canvas overlay dimensions updated");
				}
			}

			public function connectionSuccessHandler():void{
				LOGGER.debug("connectionSuccessHandler" + streamId);
				ns = new NetStream(nc);
				ns.addEventListener( NetStatusEvent.NET_STATUS, onNetStatus );
				ns.addEventListener(AsyncErrorEvent.ASYNC_ERROR, onAsyncError);
				ns.client = this;

				ns.bufferTime = 0;
				ns.receiveVideo(true);
				ns.receiveAudio(false);

				video = new Video(videoWidth, videoHeight);

				video.attachNetStream(ns);
				ns.play(streamId);

				videoWithWarnings.setCallback(setVideo);
			}

			private function netStatusHandler(event:NetStatusEvent):void {
				var ce:WebRTCConnectionEvent = new WebRTCConnectionEvent();

				switch(event.info.code){
					case "NetConnection.Connect.Failed":
						ce.status = WebRTCConnectionEvent.FAILED;
						break;

					case "NetConnection.Connect.Success":
						ce.status = WebRTCConnectionEvent.SUCCESS;
						connectionSuccessHandler();
						break;

					case "NetConnection.Connect.Rejected":
						ce.status = WebRTCConnectionEvent.REJECTED;
						break;

					case "NetConnection.Connect.Closed":
						LOGGER.debug("Deskshare connection closed.");
						ce.status = WebRTCConnectionEvent.CLOSED;
						break;

					case "NetConnection.Connect.InvalidApp":
						ce.status = WebRTCConnectionEvent.INVALIDAPP;
						break;

					case "NetConnection.Connect.AppShutdown":
						ce.status = WebRTCConnectionEvent.APPSHUTDOWN;
						break;

					case "NetConnection.Connect.NetworkChange":
						LOGGER.debug("Detected network change.");
						break;
				}
			}

			private function securityErrorHandler(event:SecurityErrorEvent):void {
				LOGGER.debug("ERROR DesktopViewWindow::securityErrorHandler ");
			}

			public function stopViewing():void {
				ns.close();
			}

			private function onStopViewStreamEvent(event:ViewStreamEvent):void {
				stopViewing();
			}

			private function onAsyncError(e:AsyncErrorEvent):void{
				LOGGER.debug("VIdeoWindow::asyncerror {0}", [e.toString()]);
			}

			private function onNetStatus(e:NetStatusEvent):void{
				LOGGER.debug("onNetStatus info={0}", [e.info.text]);

				switch(e.info.code){
				case "NetStream.Play.Start":
					LOGGER.debug("NetStream.Publish.Start for {0}", [streamId]);
					LOGGER.debug("Dispatching start viewing event");
					break;

				case "NetStream.Play.UnpublishNotify":
					LOGGER.debug("NetStream.Play.UnpublishNotify for {0}", [streamId]);
					stopViewing();
					break;
				}
			}

			public function onBWCheck(... rest):Number {
				return 0;
			}

			public function onBWDone(... rest):void {
				var p_bw:Number;
				if (rest.length > 0) p_bw = rest[0];
				// your application should do something here
				// when the bandwidth check is complete
				LOGGER.debug("bandwidth = " + p_bw + " Kbps.");
			}

			private function localeChanged(e:Event):void{
				resourcesChanged();
			}

			private function toggleActualSize():void {
				actualSize = !actualSize;
			}

			public function set actualSize(value:Boolean):void {
				_actualSize = value;
				onResizeEvent();
			}

			public function onParentResized():void {
				onResizeEvent();
			}

			public function get actualSize():Boolean {
				return _actualSize;
			}

			/** Inherited from IBbbCanvas*/

			public function addRawChild(child:DisplayObject):void {
				whiteboardCanvasHolder.rawChildren.addChild(child);
			}

			public function removeRawChild(child:DisplayObject):void {
				this.whiteboardCanvasHolder.rawChildren.removeChild(child);
			}

			public function doesContain(child:DisplayObject):Boolean {
				return this.whiteboardCanvasHolder.rawChildren.contains(child);
			}

			public function acceptOverlayCanvas(overlay:IBbbCanvas):void {
				cleanCanvasHolder();
				whiteboardCanvas = overlay;
			}

			private function handleWhiteboardCanvasClick(e:MouseEvent):void {
				LOGGER.debug("handleWhiteboardCanvasClick");
			}

			public function moveCanvas(x:Number, y:Number):void {
				LOGGER.debug("moveCanvas");
			}

			public function zoomCanvas(width:Number, height:Number, zoom:Number):void {
				LOGGER.debug("zoomCanvas");
			}

			public function showCanvas(show:Boolean):void {
				LOGGER.debug("showCanvas");
			}
		]]>
	</mx:Script>
</mx:Canvas>
